---
title: "Single-cell RNA-Seq analysis of CD8+ SARS-CoV-2 specific T cells"
output:
  word_document: default
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(Seurat)
library(plyr)
library(dplyr)
library(patchwork)
library(cowplot)
library(ggplot2)
library(data.table)
library(tidyverse)
library(harmony)
```

# All CD8 samples
Analysis of Dong samples: CD8 NP16 & ORF3a-28
Follow guided clustering tutorial https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html and this one https://scrnaseq-course.cog.sanger.ac.uk/website/seurat-chapter.html


## Load counts matrix and create Seurat object
```{r loading}
setwd('/t1-data/user/lfelce/scRNA-Seq/SmartSeq2_T-cells/')

# load data (from featureCounts)
tcell_data <-  fread('201203_counts.txt', stringsAsFactors = F, header=T)

# remove columns with chromosome, start, end, strand and length info
tcell_data <- tcell_data[,-c(2:6)]

# make Geneid into row names
tcell_data <-tibble::column_to_rownames(tcell_data, "Geneid")

# tidy up sample names
names(tcell_data) <- gsub(x = names(tcell_data), pattern = "./", replacement = "")
names(tcell_data) <- gsub(x = names(tcell_data), pattern = ".bam", replacement = "")

# select CD8 cells only but leave out 1131-TP-1 - should have 816
sample_list <- as.data.frame(colnames(tcell_data))
tcell_data2 <- tcell_data[,-c(481:486,774:779,1404:1409)]
sample_list2 <- as.data.frame(colnames(tcell_data2))
cd8_data <- tcell_data2[,c(1:192, 481:576, 672:1055, 1344:1487)]

# load new 1131-TP-1 data and process
data_1131_new <- fread('201221_counts.txt', stringsAsFactors = F, header=T)
data_1131_new <- data_1131_new[,-c(2:6)]
data_1131_new <-tibble::column_to_rownames(data_1131_new, "Geneid")
names(data_1131_new) <- gsub(x = names(data_1131_new), pattern = "./", replacement = "")
names(data_1131_new) <- gsub(x = names(data_1131_new), pattern = ".bam", replacement = "")

# leave out bulk samples
list_1131 <- as.data.frame(colnames(data_1131_new))
data_1131_new <- data_1131_new[,-c(25:96)]

# merge with cd8_data = 816 + 92 = 908
cd8_data <- cbind(cd8_data, data_1131_new)

# # Initialise Seurat object with raw (non-normalised) data
# # min.cells = include features detected in at least this many cells
# # min.features includes cells where at least this many features detected
# cd8 <- CreateSeuratObject(counts = cd8_data, min.cells = 3, min.features = 200, project = "CD8 T-cell_data", assay = "RNA")
```

## Standard pre-processing workflow

### QC and selecting cells for further analysis
Minimum gene cut off already set with CreateSeuratObject, but can filter out cells based on technical or biological parameters.
Visualise gene and molecule counts, plot relationship and exclude cells with clear outlier number of genes detected as potential multiplets (filter user-defined outlier cells). 

Also filter cells based on % mitochondrial genes present:

```{r qc, fig.height=6, fig.width=16}
# # non-UMI data - nUMI represents sum of non-normalised values within cells
# # calculate % mitochondrial genes and store in separate object
# # use object@raw.data represents non-transformed and non-log-normalised counts
# # % of UMI mapping to MT-genes is a common scRNA-seq QC metric
# mito.genes <- grep(pattern = "^MT-", x = rownames(cd8@assays[["RNA"]]), value = TRUE)
# percent.mito <- Matrix::colSums(cd8@assays[["RNA"]][mito.genes, ])/Matrix::colSums(cd8@assays[["RNA"]])
# cd8 <- AddMetaData(object = cd8, metadata = percent.mito, col.name = "percent.mito") 
# VlnPlot(object = cd8, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"), ncol = 3)
# # all cells have same value % mitochondrial cells?
```

```{r, fig.height=4, fig.width=6}
# can use GenePlot to visualise gene-gene relationships and anything else calculated by object
# FeatureScatter(object=cd8, feature1="nCount_RNA", feature2="nFeature_RNA")
```


```{r filtering}
# Filter out cells that have unique gene counts (nFeature_RNA) over 4000 or less than 200 
# Note that > and < are used to define a'gate'.  
# -Inf and Inf should be used if don't want a lower or upper threshold.
# cd8 <- subset(x = cd8, subset = nFeature_RNA > 200 & nFeature_RNA < 4000 & percent.mito >  -Inf & percent.mito < 0.05 )
```

### Normalising the data
After removing unwanted cells from dataset, need to normalise data. Use global-scaling normalisation method "LogNormalize" - normalises gene expression measurements for each cell by total expression, multiplies by scale factor (10,000 default) and log-tranforms result.
```{r normalisation}
# cd8 <- NormalizeData(object = cd8, normalization.method = "LogNormalize", scale.factor = 10000)
```

### Detection of variables genes across single cells
Seurat calculates highly variable genes and focuses on these for downstream analysis. FindVariableGenes calculates average expression and dispersion for each gene, places genes into bins and calculates z-score for dispersion within each bin - helps to control relationship between variability and average expression. 

```{r variability, fig.height=8, fig.width = 16}
# # identify 2000 variable genes - normal parameter settings for UMI data normalised to total of 1e4 molecules
# cd8 <- FindVariableFeatures(object = cd8, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5, nfeatures = 2000)
# # Identify the 10 most highly variable genes
# top10 <- head(VariableFeatures(cd8), 10)
# # plot variable features with and without labels
# plot1 <- VariableFeaturePlot(cd8)
# plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
# plot1 + plot2
```
### Scaling data and removing unwanted sources of variation
Dataset may include uninteresting sources of variation - technical noise, batch effects, biological sources of variation (cell cycle) - regressing these signals can improve downstream dimensionality reduction and clustering. To judge effects of these signals, Seurat constructs linear models to predict gene expression based on user-defined variables. Scaled z-scored residuals of these models are stored in scale.data slot, used for dimensionality reduction and clustering.

```{r scaling}
# cd8 <- ScaleData(object = cd8, vars.to.regress = c("nCounts_RNA", "percent.mito"))
```

### Linear dimensional reduction (PCA)
Perform PCA on scaled data. Not sure if highly variable genes or pc.genes are input?

```{r pca, fig.height=4, fig.width=6}
# cd8 <- RunPCA(object = cd8,  npcs = 30, verbose = FALSE)
# #standard PCA plot
# DimPlot(object = cd8, reduction = "pca")
```

Using a heatmap can be useful to look at primary sources of heterogeneity in a dataset, and can use to decide which PCs to include for further downstream analysis. 

```{r pca heatmap, fig.height=4, fig.width=6}
# DimHeatmap(object = cd8, reduction = "pca", cells = 200, balanced = TRUE)
```

### Determine statistically significant principal components
Overcome extensive technical noise in any single gene for scRNA-seq data, Seurat clusters cells based on PCA scores. Determining how many PCs to include downstream is an important step.

Here it looks like PC1-8 are significant (looking at p-values)
```{r jackstraw, fig.height=4, fig.width=6}
# cd8 <- JackStraw(cd8, num.replicate = 100)
# # visualise distribution of p-values for each PC with uniform distribution (dashed line) Significant PCs show strong enrichment of genes with low p-values (solid curve above dashed line)
# cd8 <- ScoreJackStraw(cd8, dims = 1:20)
# JackStrawPlot(cd8, dims = 1:15)
```


## Cell clustering
Construct a k-nearest neighbours graph based on Euclidean distance in PCA space, refine edge weights between any 2 cells based on shared overlap in local neighbourhoods. Use Louvain algorithm to cluster cells - modularity optimisation technique to iteratively group cells together.

Resolution parameter - sets granularity of downstream clustering, larger values leads to more clusters. Set between 0.6-1.2 for single cell datasets around 3000 cells. 

```{r clustering}
# calculate KNN and construct SNN graph (find neighbours), then find clusters
# cd8 <- FindNeighbors(cd8, dims = 1:8)
# cd8 <- FindClusters(cd8, resolution = 0.4)
```
### Non-linear dimensional reduction (UMAP)
Place similar cells in low-dimensional space. Use same PCs as input to clustering analysis
```{r umap, fig.height=5, fig.width=16}
# cd8 <- RunUMAP(cd8, dims = 1:8)
# # plot UMAP and labels by cluster
# Idents(cd8) <- "seurat_clusters"
# UMAP_cluster <- DimPlot(cd8, reduction = "umap", group.by = "seurat_clusters")
# # plot UMAP and label by patient
# UMAP_patient <- DimPlot(cd8, reduction = "umap", group.by = "orig.ident")
# UMAP_cluster + UMAP_patient
```

## Finding differentially expressed genes (cluster biomarkers)
Define clusters via differential expression. Identifies positive and negative markers of single cluster compared to all other cells.

```{r number of cells}
# # How many cells for each patient?
# Idents(cd8) <- "orig.ident"
# table(Idents(cd8))
# # How many cells in each cluster?
# Idents(cd8) <- "seurat_clusters"
# table(Idents(cd8))
```


```{r markers}
# find markers for every cluster compared to remaining cells, report only positive ones
# Wilcoxon Rank Sum test default
# cd8.markers <- FindAllMarkers(object = cd8, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
# write.csv (cd8.markers, "cd8-tcell_markers.csv")
# divide file into separate clusters
# cluster_0 <- cd8.markers[cd8.markers$cluster == "0", ]
# cluster_1 <- cd8.markers[cd8.markers$cluster == "1", ]
# cluster_2 <- cd8.markers[cd8.markers$cluster == "2", ]
# cluster_3 <- cd8.markers[cd8.markers$cluster == "3", ]
# write.csv (cluster_0, "cluster_0.csv")
# write.csv (cluster_1, "cluster_1.csv")
# write.csv (cluster_2, "cluster_2.csv")
# write.csv (cluster_3, "cluster_3.csv")
# show top 2 differentially expressed genes per cluster
# cd8.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_log2FC)
```


```{r heatmap}
# Expression heatmap for top 20 markers for each cluster
# top10 <- cd8.markers %>% group_by(cluster) %>% top_n(10, avg_log2FC)
# setting slim.col.label to TRUE will print just the cluster IDS instead of every cell name
# DoHeatmap(object = cd8, features = top10$gene, label = TRUE)
```

# Annotating UMAPs with meaningful information
## Known information
### Severity
```{r severity annotation, fig.height=4, fig.width=6}
# # assign known identities to clusters - look at known clinical description
# clin.type <- rep(c("mild", "severe","severe","severe","severe","severe","mild", "severe","severe"), 
#                  times = c("133", "94", "62", "74", "95", "66", "75", "46", "95"))
# cd8@meta.data$"clin.type" <- as.factor(clin.type)
# UMAP_clin <- DimPlot(cd8, reduction = "umap", group.by = "clin.type", label = TRUE, label.size = 3 ,repel = TRUE)
# UMAP_clin
```
### Epitope
```{r known epitopes, fig.height=4, fig.width=6}
# # assign known identities to clusters - look at known epitopes
# epitope <- rep(c("NP16", "ORF3a-28", "NP16", "NP16", "ORF3a-28", "NP16", "NP16", "ORF3a-28","ORF3a-28"), 
#                  times = c("133", "94", "62", "74", "95", "66", "75", "46", "95"))
# cd8@meta.data$"epitope" <- as.factor(epitope)
# UMAP_epitope <- DimPlot(cd8, reduction = "umap", group.by = "epitope", label = TRUE, label.size = 3 ,repel = TRUE)
# # use split.by="seurat_clusters" to also show UMAP by epitope and cluster number
# UMAP_epitope
```


## Gene expression by epitope

```{r, fig.height=32, fig.width=16}
# VlnPlot(object = cd8, features = c("CD27", "IL7R", "S100A4", "PTPRC", 
#                                    "CCR7", "SELL", "CD44", "CD69", 
#                                    "HLA-DRB1", "CCL4", 
#                                    "CCL5", "CXCR3", "CXCR4",
#                                    "IL16", "IFNG", 
#                                    "PRF1", "GNLY", "NKG7", 
#                                    "GZMA", "GZMB", "GZMH", "GZMK",
#                                    "FASLG", "ISG15",
#                                    "PDCD1", "CTLA4", "HAVCR2", "CD244",
#                                    "KLRG1", "TIGIT", "BTLA", "CD160"), 
#         ncol=4, group.by = "epitope")
```

# Integrate CD8 patients using Harmony (recommended by Adam)
Harmony integration carried out on BMRC cluster R studio with locally installed Harmony package and Seurat.
Loaded cd8_seurat.rds from 28th December 2020 for previously created and analysed cd8 Seurat object.

http://htmlpreview.github.io/?https://github.com/immunogenomics/harmony/blob/master/docs/SeuratV3.html
IMPORTANT DIFFERENCE: In the Seurat integration tutorial, you need to define a Seurat object for each dataset. With Harmony integration, create only one Seurat object with all cells.

The simplest way to run Harmony is to pass the Seurat object and specify which variable(s) to integrate out. RunHarmony returns a Seurat object, updated with the corrected Harmony coordinates. Let's set plot_convergence to TRUE, so we can make sure that the Harmony objective function gets better with each round.

```{r harmony1}
# cd8 <- readRDS("cd8_seurat.rds")
# options(repr.plot.height = 2.5, repr.plot.width = 6)
# cd8 <- cd8 %>% 
#     RunHarmony("orig.ident", plot_convergence = TRUE)
# # Harmony converged after 8 iterations
# # access Harmony embeddings - show top 5 rows and top 5 columns
# harmony_embeddings <- Embeddings(cd8, 'harmony')
```

```{r harmony2, fig.height=5, fig.width=12}
# p1 <- DimPlot(object = cd8, reduction = "harmony", group.by = "orig.ident")
# p2 <- VlnPlot(object = cd8, features = "harmony_1", group.by = "orig.ident", pt.size = .1)
# p1 + p2
```
```{r harmony3, fig.height=5, fig.width=12}
# p3 <- DimPlot(object = cd8, reduction = "pca", group.by="orig.ident")
# p3 + p1
```

Many downstream analyses are performed on low dimensional embeddings, not gene expression. To use the corrected Harmony embeddings rather than PCs, set reduction = 'harmony'. For example, let's perform the UMAP and Nearest Neighbor analyses using the Harmony embeddings.
```{r harmony_umap, fig.height=5, fig.width=20}
# cd8 <- cd8 %>% 
#     RunUMAP(reduction = "harmony", dims = 1:20) %>% 
#     FindNeighbors(reduction = "harmony", dims = 1:20) %>% 
#     FindClusters(resolution = 0.5) %>% 
#     identity()
# umap_patient <- DimPlot(cd8, reduction = "umap", group.by = "orig.ident")
# umap_epitope <- DimPlot(cd8, reduction = "umap", group.by = "epitope")
# umap_cluster <- DimPlot(cd8, reduction = "umap", group.by = "seurat_clusters")
# umap_patient + umap_epitope + umap_cluster
```

```{r harmony_markers}
# cd8.markers <- FindAllMarkers(object = cd8, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
# cluster_0 <- cd8.markers[cd8.markers$cluster == "0", ]
# cluster_1 <- cd8.markers[cd8.markers$cluster == "1", ]
# cluster_2 <- cd8.markers[cd8.markers$cluster == "2", ]
# cluster_3 <- cd8.markers[cd8.markers$cluster == "3", ]
# cluster_4 <- cd8.markers[cd8.markers$cluster == "4", ]
# tmarkers <- read.csv("Markers_for_Ling.csv", header=F)
# genes_0 <- tmarkers[is.element(tmarkers$V1, cluster_0$gene),]
# genes_1 <- tmarkers[is.element(tmarkers$V1, cluster_1$gene),]
# genes_2 <- tmarkers[is.element(tmarkers$V1, cluster_2$gene),]
# genes_3 <- tmarkers[is.element(tmarkers$V1, cluster_3$gene),]
# genes_4 <- tmarkers[is.element(tmarkers$V1, cluster_4$gene),]
# markers_summary <- rbind(genes_0, genes_1, genes_2)
```
## Gene expression by epitope

```{r, fig.height=32, fig.width=16}
# VlnPlot(object = cd8, features = c("CD27", "IL7R", "S100A4", "PTPRC", 
#                                    "CCR7", "SELL", "PASK","CD44", "CD69", 
#                                    "HLA-DRB1", "CCL4", 
#                                    "CCL5", "CXCR3", "CXCR4",
#                                    "IL16", "IFNG", 
#                                    "PRF1", "GNLY", "NKG7", 
#                                    "GZMA", "GZMB", "GZMH", "GZMK",
#                                    "FASLG", "ISG15", "MX1", "TUBA1B",
#                                    "MKI67",
#                                    "PDCD1", "CTLA4", "HAVCR2", "CD244",
#                                    "KLRG1", "TIGIT", "BTLA", "CD160"), 
#         ncol=4, group.by = "epitope")
```

```{r, fig.height=32, fig.width=16}
# VlnPlot(object = cd8, features = c("CD27", "IL7R", "S100A4", "PTPRC", 
#                                    "CCR7", "SELL", "PASK","CD44", "CD69", 
#                                    "HLA-DRB1", "CCL4", 
#                                    "CCL5", "CXCR3", "CXCR4",
#                                    "IL16", "IFNG", 
#                                    "PRF1", "GNLY", "NKG7", 
#                                    "GZMA", "GZMB", "GZMH", "GZMK",
#                                    "FASLG", "ISG15", "MX1", "TUBA1B",
#                                    "MKI67",
#                                    "PDCD1", "CTLA4", "HAVCR2", "CD244",
#                                    "KLRG1", "TIGIT", "BTLA", "CD160"), 
#         ncol=4, group.by = "seurat_clusters")
```
```{r}
# # Expression heatmap for top 20 markers for each cluster
# top10 <- cd8.markers %>% group_by(cluster) %>% top_n(10, avg_log2FC)
# # setting slim.col.label to TRUE will print just the cluster IDS instead of every cell name
# DoHeatmap(object = cd8, features = top10$gene, label = TRUE)

```


# Integrate CD8 patients separately FindIntegrationAnchors and IntegrateData (Seurat)
```{r integrate, include=FALSE}
# cd8_fresh <- CreateSeuratObject(counts = cd8_data, min.cells = 3, min.features = 200, project = "CD8 T-cell_data", assay = "RNA")
# split by patient - orig.ident from metadata (new patient 1131-TP-1)
# cd8.list <- SplitObject(cd8_fresh, split.by="orig.ident")
# cd8.list <- cd8.list[c("005", "1105", "1131-TP-1", "1131-TP-2", 
#                                "1134-TP-2", "1153", "1201-TP-2",
#                                "1525-TP-1", "1525-TP-2")]
# for (i in 1:length(cd8.list)) {
#     cd8.list[[i]] <- NormalizeData(cd8.list[[i]], verbose = FALSE)
#     cd8.list[[i]] <- FindVariableFeatures(cd8.list[[i]], selection.method = "vst", 
#         nfeatures = 2000, verbose = FALSE)
# }
# cd8.anchors <- FindIntegrationAnchors(object.list = cd8.list, dims = 1:30, k.filter=48, verbose=FALSE)
# cd8.integrated <- IntegrateData(anchorset = cd8.anchors, dims = 1:30, k.weight=48, verbose=FALSE)
```

```{r processing data, include=FALSE}
# cd8.integrated <- ScaleData(cd8.integrated, verbose = FALSE)
# cd8.integrated <- RunPCA(cd8.integrated, npcs = 30, verbose = FALSE)
# cd8.integrated <- FindNeighbors(cd8.integrated, dims = 1:8)
# cd8.integrated <- FindClusters(cd8.integrated, resolution = 0.5)
# cd8.integrated <- RunUMAP(cd8.integrated, reduction = "pca", dims = 1:8, verbose = FALSE)
```

### Cluster + patient UMAP
```{r int umap, fig.height=5, fig.width=16}
# # plot UMAP and labels by cluster
# UMAP_int_cluster <- DimPlot(cd8.integrated, reduction = "umap", group.by="seurat_clusters")
# # plot UMAP and label by patient
# UMAP_int_patient <- DimPlot(cd8.integrated, reduction = "umap", group.by = "orig.ident")
# UMAP_int_cluster + UMAP_int_patient
```

### Epitope UMAP
```{r int epitopes, fig.height=4, fig.width=6}
# # assign known identities to clusters - look at known epitopes
# epitope <- rep(c("NP16", "ORF3a-28", "NP16", "NP16", "ORF3a-28", "NP16", "NP16", "ORF3a-28","ORF3a-28"), 
#                  times = c("133", "95", "70", "74", "95", "66", "75", "48", "95"))
# cd8.integrated@meta.data$"epitope" <- as.factor(epitope)
# UMAP_int_epitope <- DimPlot(cd8.integrated, reduction = "umap", group.by = "epitope")
# # use split.by="seurat_clusters" to also show UMAP by epitope and cluster number
# UMAP_int_epitope
```

## Gene expression by epitope

```{r, fig.height=32, fig.width=16}
# DefaultAssay(cd8.integrated) <- "RNA"
# VlnPlot(object = cd8.integrated, features = c("CD27", "IL7R", "S100A4", "PTPRC", 
#                                    "CCR7", "SELL", "CD44", "CD69", 
#                                    "HLA-DRB1", "CCL4", 
#                                    "CCL5", "CXCR3", "CXCR4",
#                                    "IL16", "IFNG", 
#                                    "PRF1", "GNLY", "NKG7", 
#                                    "GZMA", "GZMB", "GZMH", "GZMK",
#                                    "FASLG", "ISG15",
#                                    "PDCD1", "CTLA4", "HAVCR2", "CD244",
#                                    "KLRG1", "TIGIT", "BTLA", "CD160"), 
#         ncol=4, group.by = "epitope")
```

# Acute patients
Analyse acute patients separately - 1131-TP-1 (NP16) and 1525-TP-1 (ORF3a-28)
## Processing data
```{r}
# select only columns containing TP-1
acute_data <- select(cd8_data,contains("TP-1"))
acute <- CreateSeuratObject(counts = acute_data, min.cells = 3, min.features = 200, project = "CD8 acute T-cell data", assay = "RNA")

# non-UMI data - nUMI represents sum of non-normalised values within cells
# calculate % mitochondrial genes and store in separate object
# use object@raw.data represents non-transformed and non-log-normalised counts
# % of UMI mapping to MT-genes is a common scRNA-seq QC metric
mito.genes <- grep(pattern = "^MT-", x = rownames(acute@assays[["RNA"]]), value = TRUE)

percent.mito <- Matrix::colSums(acute@assays[["RNA"]][mito.genes, ])/Matrix::colSums(acute@assays[["RNA"]])

acute <- AddMetaData(object = acute, metadata = percent.mito, col.name = "percent.mito")

VlnPlot(object = acute, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"), ncol = 3)
# all cells have same value % mitochondrial cells?
```

```{r, fig.height=4, fig.width=6}
# can use GenePlot to visualise gene-gene relationships and anything else calculated by object
FeatureScatter(object=acute, feature1="nCount_RNA", feature2="nFeature_RNA")
```


```{r, fig.height=8, fig.width = 16}
# Filter out cells that have unique gene counts (nFeature_RNA) over 4000 or less than 200 
# Note that > and < are used to define a'gate'.  
# -Inf and Inf should be used if don't want a lower or upper threshold.
acute <- subset(x = acute, subset = nFeature_RNA > 200 & nFeature_RNA < 4000 & percent.mito >  -Inf & percent.mito < 0.05 )

# After removing unwanted cells from dataset, need to normalise data. Use global-scaling normalisation method "LogNormalize" - normalises gene expression measurements for each cell by total expression, multiplies by scale factor (10,000 default) and log-tranforms result.

acute <- NormalizeData(object = acute, normalization.method = "LogNormalize", scale.factor = 10000)

# identify 2000 variable genes - normal parameter settings for UMI data normalised to total of 1e4 molecules
acute <- FindVariableFeatures(object = acute, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5, nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(acute), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(acute)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2
```



```{r, fig.height=4, fig.width=6}
acute <- ScaleData(object = acute, vars.to.regress = c("nCounts_RNA", "percent.mito"))

acute <- RunPCA(object = acute,  npcs = 30, verbose = FALSE)

# standard PCA plot
p3 <- DimPlot(object = acute, reduction = "pca")
p3
```
## Harmony integration 
```{r}
acute <- acute %>% 
    RunHarmony("orig.ident", plot_convergence = TRUE)
# Harmony converged after 3 iterations
harmony_embeddings <- Embeddings(acute, 'harmony')

```

```{r, fig.height=5, fig.width=20}
p1 <- DimPlot(object = acute, reduction = "harmony", group.by = "orig.ident")
p2 <- VlnPlot(object = acute, features = "harmony_1", group.by = "orig.ident", pt.size = .1)
p3 + p1 + p2
```
```{r, fig.height=5, fig.width=12}
acute <- acute %>% 
    RunUMAP(reduction = "harmony", dims = 1:20) %>% 
    FindNeighbors(reduction = "harmony", dims = 1:20) %>% 
    FindClusters(resolution = 0.5) %>% 
    identity()
umap_patient <- DimPlot(acute, reduction = "umap", group.by = "orig.ident")
umap_cluster <- DimPlot(acute, reduction = "umap", group.by = "seurat_clusters")
umap_patient + umap_cluster
```

```{r}
acute.markers <- FindAllMarkers(object = acute, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)

cluster_0 <- acute.markers[acute.markers$cluster == "0", ]
cluster_1 <- acute.markers[acute.markers$cluster == "1", ]

tmarkers <- read.csv("Markers_for_Ling.csv", header=F)

genes_0 <- tmarkers[is.element(tmarkers$V1, cluster_0$gene),]
genes_1 <- tmarkers[is.element(tmarkers$V1, cluster_1$gene),]


```

## Gene expression by patient

```{r, fig.height=32, fig.width=16}
VlnPlot(object = acute, features = c("CD27", "IL7R", "S100A4", "PTPRC", 
                                   "CCR7", "SELL", "CD44", "CD69", 
                                   "HLA-DRB1", "CCL4", 
                                   "CCL5", "CXCR3", "CXCR4",
                                   "IL16", "IFNG", 
                                   "PRF1", "GNLY", "NKG7", 
                                   "GZMA", "GZMB", "GZMH", "GZMK",
                                   "FASLG", "ISG15",
                                   "PDCD1", "CTLA4", "HAVCR2", "CD244",
                                   "KLRG1", "TIGIT", "CD160"), 
        ncol=4, group.by = "orig.ident")
```


## Gene expression by cluster
```{r, fig.height=32, fig.width=16}
VlnPlot(object = acute, features = c("CD27", "IL7R", "S100A4", "PTPRC", 
                                   "CCR7", "SELL", "CD44", "CD69", 
                                   "HLA-DRB1", "CCL4", 
                                   "CCL5", "CXCR3", "CXCR4",
                                   "IL16", "IFNG", 
                                   "PRF1", "GNLY", "NKG7", 
                                   "GZMA", "GZMB", "GZMH", "GZMK",
                                   "FASLG", "ISG15",
                                   "PDCD1", "CTLA4", "HAVCR2", "CD244",
                                   "KLRG1", "TIGIT", "CD160"), 
        ncol=4, group.by = "seurat_clusters")
```


# Convalescent patients
Analyse convalescent patients separately - all patients except 1131-TP-1 and 1525-TP-1
## Processing data
```{r}
# remove any columns containing TP-1
conv_data <- cd8_data %>% select(!(contains("TP-1")))

conv <- CreateSeuratObject(counts = conv_data, min.cells = 3, min.features = 200, project = "CD8 conv T-cell data", assay = "RNA")

# non-UMI data - nUMI represents sum of non-normalised values within cells
# calculate % mitochondrial genes and store in separate object
# use object@raw.data represents non-transformed and non-log-normalised counts
# % of UMI mapping to MT-genes is a common scRNA-seq QC metric

mito.genes <- grep(pattern = "^MT-", x = rownames(conv@assays[["RNA"]]), value = TRUE)

percent.mito <- Matrix::colSums(conv@assays[["RNA"]][mito.genes, ])/Matrix::colSums(conv@assays[["RNA"]])

conv <- AddMetaData(object = conv, metadata = percent.mito, col.name = "percent.mito")

VlnPlot(object = conv, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"), ncol = 3)
# all cells have same value % mitochondrial cells?
```

```{r, fig.height=4, fig.width=6}
# can use GenePlot to visualise gene-gene relationships and anything else calculated by object
FeatureScatter(object=conv, feature1="nCount_RNA", feature2="nFeature_RNA")
```


```{r, fig.height=8, fig.width = 16}
# Filter out cells that have unique gene counts (nFeature_RNA) over 4000 or less than 200 
# Note that > and < are used to define a'gate'.  
# -Inf and Inf should be used if don't want a lower or upper threshold.
conv <- subset(x = conv, subset = nFeature_RNA > 200 & nFeature_RNA < 4000 & percent.mito >  -Inf & percent.mito < 0.05 )

# After removing unwanted cells from dataset, need to normalise data. Use global-scaling normalisation method "LogNormalize" - normalises gene expression measurements for each cell by total expression, multiplies by scale factor (10,000 default) and log-tranforms result.
conv <- NormalizeData(object = conv, normalization.method = "LogNormalize", scale.factor = 10000)

# identify 2000 variable genes - normal parameter settings for UMI data normalised to total of 1e4 molecules
conv <- FindVariableFeatures(object = conv, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5, nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(conv), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(conv)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2
```



```{r, fig.height=4, fig.width=6}
conv <- ScaleData(object = conv, vars.to.regress = c("nCounts_RNA", "percent.mito"))
conv <- RunPCA(object = conv,  npcs = 30, verbose = FALSE)

# standard PCA plot
p3 <- DimPlot(object = conv, reduction = "pca")
p3
```
## Harmony integration 
```{r}
conv <- conv %>% 
    RunHarmony("orig.ident", plot_convergence = TRUE)
# Harmony converged after 7 iterations
harmony_embeddings <- Embeddings(conv, 'harmony')
```

```{r, fig.height=5, fig.width=20}
p1 <- DimPlot(object = conv, reduction = "harmony", group.by = "orig.ident")
p2 <- VlnPlot(object = conv, features = "harmony_1", group.by = "orig.ident", pt.size = .1)
p3 + p1 + p2
```

```{r, fig.height=5, fig.width=12}
conv <- conv %>% 
    RunUMAP(reduction = "harmony", dims = 1:25) %>% 
    FindNeighbors(reduction = "harmony", dims = 1:25) %>% 
    FindClusters(resolution = 0.5) %>% 
    identity()
umap_patient <- DimPlot(conv, reduction = "umap", group.by = "orig.ident")
umap_cluster <- DimPlot(conv, reduction = "umap", group.by = "seurat_clusters")
umap_patient + umap_cluster
```

```{r}
conv.markers <- FindAllMarkers(object = conv, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
cluster_0 <- conv.markers[conv.markers$cluster == "0", ]
cluster_1 <- conv.markers[conv.markers$cluster == "1", ]
cluster_2 <- conv.markers[conv.markers$cluster == "2", ]
cluster_3 <- conv.markers[conv.markers$cluster == "3", ]

tmarkers <- read.csv("Markers_for_Ling.csv", header=F)

genes_0 <- tmarkers[is.element(tmarkers$V1, cluster_0$gene),]
genes_1 <- tmarkers[is.element(tmarkers$V1, cluster_1$gene),]
genes_2 <- tmarkers[is.element(tmarkers$V1, cluster_2$gene),]
genes_3 <- tmarkers[is.element(tmarkers$V1, cluster_3$gene),]
```

## Gene expression by patient

```{r, fig.height=32, fig.width=16}
VlnPlot(object = conv, features = c("CD27", "IL7R", "S100A4", "PTPRC", 
                                   "CCR7", "SELL", "CD44", "CD69", 
                                   "HLA-DRB1", "CCL4", 
                                   "CCL5", "CXCR3", "CXCR4",
                                   "IL16", "IFNG", 
                                   "PRF1", "GNLY", "NKG7", 
                                   "GZMA", "GZMB", "GZMH", "GZMK",
                                   "FASLG", "ISG15",
                                   "PDCD1", "CTLA4", "HAVCR2", "CD244",
                                   "KLRG1", "TIGIT", "BTLA","CD160"), 
        ncol=4, group.by = "orig.ident")
```


## Gene expression by cluster
```{r, fig.height=32, fig.width=16}
VlnPlot(object = conv, features = c("CD27", "IL7R", "S100A4", "PTPRC", 
                                   "CCR7", "SELL", "CD44", "CD69", 
                                   "HLA-DRB1", "CCL4", 
                                   "CCL5", "CXCR3", "CXCR4",
                                   "IL16", "IFNG", 
                                   "PRF1", "GNLY", "NKG7", 
                                   "GZMA", "GZMB", "GZMH", "GZMK",
                                   "FASLG", "ISG15",
                                   "PDCD1", "CTLA4", "HAVCR2", "CD244",
                                   "KLRG1", "TIGIT", "BTLA", "CD160"), 
        ncol=4, group.by = "seurat_clusters")
```
## Gene expression by epitope
```{r, fig.height=32, fig.width=16}

epitope <- rep(c("NP16", "ORF3a-28", "NP16", "ORF3a-28", "NP16", "NP16", "ORF3a-28"),
                 times = c("133", "94", "74", "95", "66", "75", "95"))
conv@meta.data$"epitope" <- as.factor(epitope)

VlnPlot(object = conv, features = c("CD27", "IL7R", "S100A4", "PTPRC", 
                                   "CCR7", "SELL", "CD44", "CD69", 
                                   "HLA-DRB1", "CCL4", 
                                   "CCL5", "CXCR3", "CXCR4",
                                   "IL16", "IFNG", 
                                   "PRF1", "GNLY", "NKG7", 
                                   "GZMA", "GZMB", "GZMH", "GZMK",
                                   "FASLG", "ISG15",
                                   "PDCD1", "CTLA4", "HAVCR2", "CD244",
                                   "KLRG1", "TIGIT", "BTLA", "CD160"), 
        ncol=4, group.by = "epitope")
```




# Save file

```{r save}
# save cd8 object at this point so don't have to redo all of the above again
# saveRDS(cd8, file = "cd8_seurat.rds")
# saveRDS(cd8.integrated, file="cd8_integrated_seurat.rds")
# saveRDS(cd8, file="cd8_harmony.rds")
saveRDS(acute, file="acute_harmony.rds")
saveRDS(conv, file="convalescent_harmony.rds")
```
