---
title: "Single-cell RNA-Seq analysis of CD8+ SARS-CoV-2 specific T cells"
output:
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(Seurat)
library(sctransform)
library(SeuratDisk)
library(SeuratData)
library(plyr)
library(dplyr)
library(patchwork)
library(cowplot)
library(ggplot2)
library(data.table)
library(tidyverse)

```

# All CD8 samples
Analysis of Dong samples: CD8 NP16 & ORF3a-28
Follow guided clustering tutorial https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html and this one https://scrnaseq-course.cog.sanger.ac.uk/website/seurat-chapter.html


## Load counts matrix and create Seurat object
```{r loading}
setwd('/t1-data/user/lfelce/scRNA-Seq/SmartSeq2_T-cells/')

# load data (from featureCounts)
tcell_data <-  fread('201203_counts.txt', stringsAsFactors = F, header=T)

# remove columns with chromosome, start, end, strand and length info
tcell_data <- tcell_data[,-c(2:6)]

# make Geneid into row names
tcell_data <-tibble::column_to_rownames(tcell_data, "Geneid")

# tidy up sample names
names(tcell_data) <- gsub(x = names(tcell_data), pattern = "./", replacement = "")  
names(tcell_data) <- gsub(x = names(tcell_data), pattern = ".bam", replacement = "")

# select CD8 cells only but leave out 1131-TP-1 - should have 816
sample_list <- as.data.frame(colnames(tcell_data))
tcell_data2 <- tcell_data[,-c(481:486,774:779,1404:1409)]
sample_list2 <- as.data.frame(colnames(tcell_data2))
cd8_data <- tcell_data2[,c(1:192, 481:576, 672:1055, 1344:1487)]

# load new 1131-TP-1 data and process
data_1131_new <- fread('201221_counts.txt', stringsAsFactors = F, header=T)
data_1131_new <- data_1131_new[,-c(2:6)]
data_1131_new <-tibble::column_to_rownames(data_1131_new, "Geneid")
names(data_1131_new) <- gsub(x = names(data_1131_new), pattern = "./", replacement = "")  
names(data_1131_new) <- gsub(x = names(data_1131_new), pattern = ".bam", replacement = "")

# leave out bulk samples
list_1131 <- as.data.frame(colnames(data_1131_new))
data_1131_new <- data_1131_new[,-c(25:96)]

# merge with cd8_data = 816 + 92 = 908
cd8_data <- cbind(cd8_data, data_1131_new)

# Initialise Seurat object with raw (non-normalised) data
# min.cells = include features detected in at least this many cells
# min.features includes cells where at least this many features detected
cd8 <- CreateSeuratObject(counts = cd8_data, min.cells = 3, min.features = 200, project = "CD8 T-cell_data", assay = "RNA")
```

## Standard pre-processing workflow

### QC and selecting cells for further analysis
Minimum gene cut off already set with CreateSeuratObject, but can filter out cells based on technical or biological parameters.
Visualise gene and molecule counts, plot relationship and exclude cells with clear outlier number of genes detected as potential multiplets (filter user-defined outlier cells). 

Also filter cells based on % mitochondrial genes present:

```{r qc, fig.height=6, fig.width=16}
# non-UMI data - nUMI represents sum of non-normalised values within cells
# calculate % mitochondrial genes and store in separate object
# use object@raw.data represents non-transformed and non-log-normalised counts
# % of UMI mapping to MT-genes is a common scRNA-seq QC metric
mito.genes <- grep(pattern = "^MT-", x = rownames(cd8@assays[["RNA"]]), value = TRUE)

percent.mito <- Matrix::colSums(cd8@assays[["RNA"]][mito.genes, ])/Matrix::colSums(cd8@assays[["RNA"]])

cd8 <- AddMetaData(object = cd8, metadata = percent.mito, col.name = "percent.mito") 

VlnPlot(object = cd8, features = c("nFeature_RNA", "nCount_RNA", "percent.mito"), ncol = 3)
# all cells have same value % mitochondrial cells?
```

```{r, fig.height=4, fig.width=6}
# can use GenePlot to visualise gene-gene relationships and anything else calculated by object
FeatureScatter(object=cd8, feature1="nCount_RNA", feature2="nFeature_RNA")
```


```{r filtering}
# Filter out cells that have unique gene counts (nFeature_RNA) over 4000 or less than 200 
# Note that > and < are used to define a'gate'.  
# -Inf and Inf should be used if don't want a lower or upper threshold.
cd8 <- subset(x = cd8, subset = nFeature_RNA > 200 & nFeature_RNA < 4000 & percent.mito >  -Inf & percent.mito < 0.05 )
```

### Normalising the data
After removing unwanted cells from dataset, need to normalise data. Use global-scaling normalisation method "LogNormalize" - normalises gene expression measurements for each cell by total expression, multiplies by scale factor (10,000 default) and log-tranforms result.
```{r normalisation}
cd8 <- NormalizeData(object = cd8, normalization.method = "LogNormalize", scale.factor = 10000)
```

### Detection of variables genes across single cells
Seurat calculates highly variable genes and focuses on these for downstream analysis. FindVariableGenes calculates average expression and dispersion for each gene, places genes into bins and calculates z-score for dispersion within each bin - helps to control relationship between variability and average expression. 

```{r variability, fig.height=8, fig.width = 16}
# identify 2000 variable genes - normal parameter settings for UMI data normalised to total of 1e4 molecules
cd8 <- FindVariableFeatures(object = cd8, mean.function = ExpMean, dispersion.function = LogVMR, x.low.cutoff = 0.0125, x.high.cutoff = 3, y.cutoff = 0.5, nfeatures = 2000)

# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(cd8), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(cd8)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2
```
### Scaling data and removing unwanted sources of variation
Dataset may include uninteresting sources of variation - technical noise, batch effects, biological sources of variation (cell cycle) - regressing these signals can improve downstream dimensionality reduction and clustering. To judge effects of these signals, Seurat constructs linear models to predict gene expression based on user-defined variables. Scaled z-scored residuals of these models are stored in scale.data slot, used for dimensionality reduction and clustering.

```{r scaling}
cd8 <- ScaleData(object = cd8, vars.to.regress = c("nCounts_RNA", "percent.mito"))
```

### Linear dimensional reduction (PCA)
Perform PCA on scaled data. Not sure if highly variable genes or pc.genes are input?

```{r pca, fig.height=4, fig.width=6}
cd8 <- RunPCA(object = cd8,  npcs = 30, verbose = FALSE)
#standard PCA plot
DimPlot(object = cd8, reduction = "pca")
```

Using a heatmap can be useful to look at primary sources of heterogeneity in a dataset, and can use to decide which PCs to include for further downstream analysis. 

```{r pca heatmap, fig.height=4, fig.width=6}
DimHeatmap(object = cd8, reduction = "pca", cells = 200, balanced = TRUE)
```

### Determine statistically significant principal components
Overcome extensive technical noise in any single gene for scRNA-seq data, Seurat clusters cells based on PCA scores. Determining how many PCs to include downstream is an important step.

Here it looks like PC1-8 are significant (looking at p-values)
```{r jackstraw, fig.height=4, fig.width=6}
cd8 <- JackStraw(cd8, num.replicate = 100)
# visualise distribution of p-values for each PC with uniform distribution (dashed line) Significant PCs show strong enrichment of genes with low p-values (solid curve above dashed line)
cd8 <- ScoreJackStraw(cd8, dims = 1:20)
JackStrawPlot(cd8, dims = 1:15)
```


## Cell clustering
Construct a k-nearest neighbours graph based on Euclidean distance in PCA space, refine edge weights between any 2 cells based on shared overlap in local neighbourhoods. Use Louvain algorithm to cluster cells - modularity optimisation technique to iteratively group cells together.

Resolution parameter - sets granularity of downstream clustering, larger values leads to more clusters. Set between 0.6-1.2 for single cell datasets around 3000 cells. 

```{r clustering}
# calculate KNN and construct SNN graph (find neighbours), then find clusters
cd8 <- FindNeighbors(cd8, dims = 1:8)
cd8 <- FindClusters(cd8, resolution = 0.4)
```
### Non-linear dimensional reduction (UMAP)
Place similar cells in low-dimensional space. Use same PCs as input to clustering analysis
```{r umap, fig.height=5, fig.width=16}
cd8 <- RunUMAP(cd8, dims = 1:8)
# plot UMAP and labels by cluster
Idents(cd8) <- "seurat_clusters"
UMAP_cluster <- DimPlot(cd8, reduction = "umap", group.by = "seurat_clusters")
# plot UMAP and label by patient
UMAP_patient <- DimPlot(cd8, reduction = "umap", group.by = "orig.ident")
UMAP_cluster + UMAP_patient
```

## Finding differentially expressed genes (cluster biomarkers)
Define clusters via differential expression. Identifies positive and negative markers of single cluster compared to all other cells.

```{r number of cells}
# How many cells for each patient?
Idents(cd8) <- "orig.ident"
table(Idents(cd8))
# How many cells in each cluster?
Idents(cd8) <- "seurat_clusters"
table(Idents(cd8))

```


```{r markers}
# find markers for every cluster compared to remaining cells, report only positive ones
# Wilcoxon Rank Sum test default
cd8.markers <- FindAllMarkers(object = cd8, only.pos = TRUE, min.pct = 0.25, thresh.use = 0.25)
write.csv (cd8.markers, "cd8-tcell_markers.csv")

# divide file into separate clusters
cluster_0 <- cd8.markers[cd8.markers$cluster == "0", ]
cluster_1 <- cd8.markers[cd8.markers$cluster == "1", ]
cluster_2 <- cd8.markers[cd8.markers$cluster == "2", ]
cluster_3 <- cd8.markers[cd8.markers$cluster == "3", ]
write.csv (cluster_0, "cluster_0.csv")
write.csv (cluster_1, "cluster_1.csv")
write.csv (cluster_2, "cluster_2.csv")
write.csv (cluster_3, "cluster_3.csv")

# show top 2 differentially expressed genes per cluster
cd8.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_log2FC)
```

```{r top 2 genes, fig.height=8, fig.width=12}
# Top 2 genes from each cluster
VlnPlot(object = cd8, features =c("GPR183", "CCR7", "FAT1", "NOTCH3", "JAK1",
                                  "NDUFA3", "MX1", "SLC7A5"), ncol=4)
```


```{r heatmap}
# Expression heatmap for top 20 markers for each cluster
top10 <- cd8.markers %>% group_by(cluster) %>% top_n(10, avg_log2FC)
# setting slim.col.label to TRUE will print just the cluster IDS instead of every cell name
DoHeatmap(object = cd8, features = top10$gene, label = TRUE)
```

# Annotating UMAPs with meaningful information
## Known information
### Severity
```{r severity annotation, fig.height=4, fig.width=6}
# assign known identities to clusters - look at known clinical description
clin.type <- rep(c("mild", "severe","severe","severe","severe","severe","mild", "severe","severe"), 
                 times = c("133", "94", "62", "74", "95", "66", "75", "46", "95"))
cd8@meta.data$"clin.type" <- as.factor(clin.type)
UMAP_clin <- DimPlot(cd8, reduction = "umap", group.by = "clin.type", label = TRUE, label.size = 3 ,repel = TRUE)
UMAP_clin
```
### Epitope
```{r known epitopes, fig.height=4, fig.width=6}
# assign known identities to clusters - look at known epitopes
epitope <- rep(c("NP16", "ORF3a-28", "NP16", "NP16", "ORF3a-28", "NP16", "NP16", "ORF3a-28","ORF3a-28"), 
                 times = c("133", "94", "62", "74", "95", "66", "75", "46", "95"))
cd8@meta.data$"epitope" <- as.factor(epitope)
UMAP_epitope <- DimPlot(cd8, reduction = "umap", group.by = "epitope", label = TRUE, label.size = 3 ,repel = TRUE)
# use split.by="seurat_clusters" to also show UMAP by epitope and cluster number
UMAP_epitope
```


## Gene expression by epitope

```{r, fig.height=32, fig.width=16}
VlnPlot(object = cd8, features = c("CD27", "IL7R", "S100A4", "PTPRC", 
                                   "CCR7", "SELL", "CD44", "CD69", 
                                   "HLA-DRB1", "CCL4", 
                                   "CCL5", "CXCR3", "CXCR4",
                                   "IL16", "IFNG", 
                                   "PRF1", "GNLY", "NKG7", 
                                   "GZMA", "GZMB", "GZMH", "GZMK",
                                   "FASLG", "ISG15",
                                   "PDCD1", "CTLA4", "HAVCR2", "CD244",
                                   "KLRG1", "TIGIT", "BTLA", "CD160"), 
        ncol=4, group.by = "epitope")

```

# Integrate CD8 patients separately using SCTransform
```{r integrate}
cd8_fresh <- CreateSeuratObject(counts = cd8_data, min.cells = 3, min.features = 200, project = "CD8 T-cell_data", assay = "RNA")

# split by patient - orig.ident from metadata (new patient 1131-TP-1)
cd8.list <- SplitObject(cd8, split.by="orig.ident")
cd8.list <- cd8.list[c("005", "1105", "1131-TP-1", "1131-TP-2", 
                               "1134-TP-2", "1153", "1201-TP-2",
                               "1525-TP-1", "1525-TP-2")]

for (i in 1:length(cd8.list)) {
    cd8.list[[i]] <- NormalizeData(cd8.list[[i]], verbose = FALSE)
    cd8.list[[i]] <- FindVariableFeatures(cd8.list[[i]], selection.method = "vst", 
        nfeatures = 2000, verbose = FALSE)
}

cd8.anchors <- FindIntegrationAnchors(object.list = cd8.list, dims = 1:30, k.filter=46, verbose=FALSE)
cd8.integrated <- IntegrateData(anchorset = cd8.anchors, dims = 1:30, k.weight=46, verbose=FALSE)
```

```{r processing data}
cd8.integrated <- ScaleData(cd8.integrated, verbose = FALSE)

cd8.integrated <- RunPCA(cd8.integrated, npcs = 30, verbose = FALSE)

cd8.integrated <- RunUMAP(cd8.integrated, reduction = "pca", dims = 1:10, verbose = FALSE)

```

### Cluster + patient UMAP
```{r umap, fig.height=5, fig.width=16}
# plot UMAP and labels by cluster
Idents(cd8.integrated) <- "seurat_clusters"
UMAP_int_cluster <- DimPlot(cd8.integrated, reduction = "umap", group.by = "seurat_clusters")

# plot UMAP and label by patient
UMAP_int_patient <- DimPlot(cd8.integrated, reduction = "umap", group.by = "orig.ident")

UMAP_int_cluster + UMAP_int_patient
```

### Epitope UMAP
```{r known epitopes, fig.height=4, fig.width=6}
# assign known identities to clusters - look at known epitopes
epitope <- rep(c("NP16", "ORF3a-28", "NP16", "NP16", "ORF3a-28", "NP16", "NP16", "ORF3a-28","ORF3a-28"), 
                 times = c("133", "94", "62", "74", "95", "66", "75", "46", "95"))

cd8.integrated@meta.data$"epitope" <- as.factor(epitope)

UMAP_int_epitope <- DimPlot(cd8.integrated, reduction = "umap", group.by = "epitope", label = TRUE, label.size = 3 ,repel = TRUE)

# use split.by="seurat_clusters" to also show UMAP by epitope and cluster number
UMAP_int_epitope
```

# Save file

```{r save}
# save cd8 object at this point so don't have to redo all of the above again
saveRDS(cd8, file = "cd8_seurat.rds")
```
